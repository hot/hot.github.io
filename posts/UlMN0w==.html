<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Mr.Hot</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
##首先让我们来看看啥是二分查找
二分查找也叫折半查找，顾名思义，就是先把`有序`的元素分成两部分，然后再看看是否需要查找的元素是在那一边。如果还没找到，那就继续把那一边也分成两半，然后重复上述过程，直到找到要找的值。

据说调查统计只有10%的人能一次将2分查找写对。少年是时候展现真正的实力了，赶紧去试下吧。

* [参考wiki](https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)
* [The Art of Programming By July](http://taop.marchtea.com/04.01.html)

##如何才能比二分查找更快？
二分查找的算法复杂度为O(logN)，而有一种数据结构能、将查找的时间复杂度降到几乎是O(1)，这种数据结构就是“[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)”。

###什么是哈希表？
哈希表也叫散列表，它通过建立关键字与存储位置之间的联系f，使得每个关键字key都对应了一个唯一的存储位置f(key)。称对应关系f为哈希函数。

###如何查找哈希表
* 存储记录时，通过哈希函数计算出记录的哈希地址
* 当查找记录时，我们通过同样的哈希函数计算记录的散列地址，并按此散列地址访问记录



###如何构造哈希函数：

参考[wiki](https://en.m.wikipedia.org/wiki/Hash_table)

###常见的冲突解决方法：
###`Separate chainning`
~~~~
在index相同的位置上存放的不是一个元素，而是一个指向List的指针
~~~~

1. hash函数计算出key的hash值
2. 通过hash值获取存储位置处的List
3. 通过遍历每个list，并比较key来取得确切位置

####list中的数据结构：
     * next指针
     * key
     * value
####时间消耗：
    hash表查找时间+list查找时间

###`Separate chainning with linked lists`
####有序链表：
    一个经过排序的链表，能增加查找速度
####根据查询的频率来排序排序链表：
    很显然，只要查询的频率变化不大的话，那就可以保证一个良好的效率

####缺点：
     * 当用来放置较小的数据的时候，next的指针所占的空间就显得比较大了。
     * 遍历链表对缓存命中率比较低
###`Separate chainning with list head cells`
    在slot中直接放置第一条记录通常情况下都能减少一次指针的跳转，这样可以提高缓存命中率。
####缺点也是很明显的：
    空的slot会和有记录的slot占用同样的空间，当记录少的时候是比较明显的空间浪费


##Open addressing
当发现slot已经被占用的时候，会根据probe sequence算法来寻找下一个空着的slot，找到后将是数据放入。取出的时候也是按照这样的方式来取。

###常见的probe sequence：
* Liner probing：以固定的步长向后寻找空的slot
* Quadratic probing：步长通过取数列中的数的平方来增长
* Double Hash：步长通过另一个hash函数来计算

Open addressing的缺陷：不能存储比slot更多的数据，当数据填充率高于70%的时候性能会急剧下降



未完待续

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">首先让我们来看看啥是二分查找</h2>

<p>二分查找也叫折半查找，顾名思义，就是先把<code>有序</code>的元素分成两部分，然后再看看是否需要查找的元素是在那一边。如果还没找到，那就继续把那一边也分成两半，然后重复上述过程，直到找到要找的值。</p>

<p>据说调查统计只有10%的人能一次将2分查找写对。少年是时候展现真正的实力了，赶紧去试下吧。</p>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">参考wiki</a></li>
<li><a href="http://taop.marchtea.com/04.01.html">The Art of Programming By July</a></li>
</ul>

<h2 id="">如何才能比二分查找更快？</h2>

<p>二分查找的算法复杂度为O(logN)，而有一种数据结构能、将查找的时间复杂度降到几乎是O(1)，这种数据结构就是“<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>”。</p>

<h3 id="">什么是哈希表？</h3>

<p>哈希表也叫散列表，它通过建立关键字与存储位置之间的联系f，使得每个关键字key都对应了一个唯一的存储位置f(key)。称对应关系f为哈希函数。</p>

<h3 id="">如何查找哈希表</h3>

<ul>
<li>存储记录时，通过哈希函数计算出记录的哈希地址</li>
<li>当查找记录时，我们通过同样的哈希函数计算记录的散列地址，并按此散列地址访问记录</li>
</ul>

<h3 id="">如何构造哈希函数：</h3>

<p>参考<a href="https://en.m.wikipedia.org/wiki/Hash_table">wiki</a></p>

<h3 id="">常见的冲突解决方法：</h3>

<h3 id="separatechainning"><code>Separate chainning</code></h3>

<pre><code>在index相同的位置上存放的不是一个元素，而是一个指向List的指针
</code></pre>

<ol>
<li>hash函数计算出key的hash值</li>
<li>通过hash值获取存储位置处的List</li>
<li>通过遍历每个list，并比较key来取得确切位置</li>
</ol>

<h4 id="list">list中的数据结构：</h4>

<pre><code> * next指针
 * key
 * value
</code></pre>

<h4 id="">时间消耗：</h4>

<pre><code>hash表查找时间+list查找时间
</code></pre>

<h3 id="separatechainningwithlinkedlists"><code>Separate chainning with linked lists</code></h3>

<h4 id="">有序链表：</h4>

<pre><code>一个经过排序的链表，能增加查找速度
</code></pre>

<h4 id="">根据查询的频率来排序排序链表：</h4>

<pre><code>很显然，只要查询的频率变化不大的话，那就可以保证一个良好的效率
</code></pre>

<h4 id="">缺点：</h4>

<pre><code> * 当用来放置较小的数据的时候，next的指针所占的空间就显得比较大了。
 * 遍历链表对缓存命中率比较低
</code></pre>

<h3 id="separatechainningwithlistheadcells"><code>Separate chainning with list head cells</code></h3>

<pre><code>在slot中直接放置第一条记录通常情况下都能减少一次指针的跳转，这样可以提高缓存命中率。
</code></pre>

<h4 id="">缺点也是很明显的：</h4>

<pre><code>空的slot会和有记录的slot占用同样的空间，当记录少的时候是比较明显的空间浪费
</code></pre>

<h2 id="openaddressing">Open addressing</h2>

<p>当发现slot已经被占用的时候，会根据probe sequence算法来寻找下一个空着的slot，找到后将是数据放入。取出的时候也是按照这样的方式来取。</p>

<h3 id="probesequence">常见的probe sequence：</h3>

<ul>
<li>Liner probing：以固定的步长向后寻找空的slot</li>
<li>Quadratic probing：步长通过取数列中的数的平方来增长</li>
<li>Double Hash：步长通过另一个hash函数来计算</li>
</ul>

<p>Open addressing的缺陷：不能存储比slot更多的数据，当数据填充率高于70%的时候性能会急剧下降</p>

<p>未完待续</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>↖(▔＾▔)↗</p>
	</div>
<!-- duoshuo -->
<div class="ds-thread" data-thread-key="UlMN0w==" data-title="怎样比二分查找更二，哦不，是更快" data-url=hot.github.io"UlMN0w==.html"></div>
<!-- duoshuo end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"hotgithub"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</div>
<script src="../main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "../main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "UlMN0w==.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
