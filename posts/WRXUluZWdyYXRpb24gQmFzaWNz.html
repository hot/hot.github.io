<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Mr.Hot</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
##简介
Hi，我是Glenn Fiedler，欢迎来到[游戏物理](http://www.gafferongames.com/game-physics/)系列的第一篇文章。

如果你曾为电脑是如何模拟物理效果感到困惑，那么这一系列文章正好可以为你答疑解惑。我将假设你能熟练使用C++语言，并且对物理和数学的基础知识有所了解。那么你就可以愉快得开始学习本系列文章了。

游戏中的物理模拟(physics simulation)的工作原理，是基于物理法则来进行许多微小的预测。这些预测实际上相当简单，基本上都可以被归纳为一些简单的事情，比方说：一个物体现在在这里，以一定速度运动，在一小段时间后它应该在那儿。我们通过一种叫做“积分”(integration)的数学技巧来实现这种预测。

##对运动方程积分
你也许还记得高中或大学的时候，物理课的知识：力 = 质量 * 加速度。变换一下这个方程，我们能得到：加速度 = 力 / 质量。这告诉我们当物体质量越大时，施加相同的力所能产生的加速度就越小。

~~~~{bash}
f = ma
a = f/m
~~~~

由于加速度其实就是速度根据时间的变化率，并且加速度等于力除以质量，综上可以得出力除以质量就是速度的变化速率

~~~~{bash}
dv/dt = a = F/m
~~~~

类似的，速度是位移相对时间的变化量

~~~~{bash}
dx/dt = v
~~~~

这意味着如果我们知道一个物体当前的位置和速度，并且知道将会施加给物体的力，我们可以通过“积分”来得到物体在未来某个时间点上的位置。

##数值积分(Numerical Integration)

对于没有在大学中系统学习过各种数学方程的朋友，不用担心，你和那些学过的朋友基本是站在同一起跑线上的。这是因为我们并不着眼于去解决学习微积分的第一年遇到的各种方程推导问题，而是将目光放在如何使用数值积分来找出问题的解决方案。

接下来让我们看看数值积分是如何运作的。首先，开始时物体具有初始的*位置*和*速度*，然后找出经过一小段时间后物体的*位置*和*速度*。不断重复上述过程，每次重复的起始位置和速度都使用上次过程产生的结果。

简单起见，让我们假设时间每次向前推进一秒。首先我们处在初始的位置，拥有初始的速度，然后让我们计算出在一秒内速度和位置的变化量是多少。然后将这些变化量累加到速度和位置上，并不断重复此过程。从初始1秒时的速度计算1秒内的变化量来得出在2秒时的速度和位置，如此反复，即可得出3，4，5秒时物体的状态。

但我们如何能知道每个时间间隔内速度的变化量是多少呢？答案就在上文所述的那堆*运动方程*中。我们通过`力`除以`质量`来得出`加速度`。 由于加速度是`每秒速度变化量`，我们能够得出`速度的变化量`为 `加速度` * `时间`(以秒为单位)。类似的，`位置的变化量`为 `速度` * `时间`。

我们将用t表示时间，用每个dt(delta time)表示时间间隔， 让我们用通俗易懂的方式来表达运动方程：

* 加速度 = 力 / 质量
* 速度变化量 = 加速度 * 时间间隔dt
* 位置变化量 = 速度 * 时间间隔dt

这些方程是有意义的，因为如果我们知道一辆车以60km每小时的速度移动，那么在一小时后这辆车将开到60km开外的地方。类似的，如果一辆车以10km/h/s的加速度，从静止开始运动，那么10秒后它将正好以100km/h的速度行驶。

让我们将这些过程转化成代码。假设最初的位置和速度都为零，我们能通过将本次时间间隔产生的位置和速度的变化量和上次时间间隔的位置和速度进行累加来实现对运动方程的积分。

~~~~{c}
float t = 0;
float dt = 1;

float velocity = 0;
float position = 0;
float force = 10;
float mass = 1;

while ( t <= 10 )
{
    position = position + velocity * dt;
    velocity = velocity + ( force / mass ) * dt;
    t = t + dt;
}
~~~~
注意积分出来的速度和位置是如何提供给下一帧的。这里每次使用最近一次计算出来的积分得到时间和位置差值来更新汽车的位置和速度，由此我们可以知道在任意一秒这辆汽车行驶了多远，以及它在以多快的速度行驶。

##为什么欧拉不总是那么完美无缺
我们上述所做的内容叫做欧拉积分(Euler Integration)。它是积分的一种特殊形式，叫做显式欧拉(explicit euler)[http://en.wikipedia.org/wiki/Euler_method]。

为了不让尴尬的事情发生，我得提前告诉你Euler的发音是"Oiler"，而不是“yew-ler”,因为欧拉积分是以发现了这个数学技巧的瑞典数学家莱昂哈德·欧拉的姓氏命名的。

欧拉积分是最基础的数值积分技巧。它只在变化率相对于时间间隔恒定的时候才有100%的正确率。例如上例中对速度的积分就是正确的，因为加速度是恒定的10米每秒。但是如果我们想通过对速度的积分来求位置的话，那就不是完全正确了。这是因为速度不是恒定值，由于加速度的存在，速度会随着时间不断改变。

这意味着随着时间的推移，积分所产生的x(t)和v(t)会和真实的值产生越来越大的偏差。在上例中，由于使用了积分，汽车的位移是不精确的。

那欧拉积分到底有多不精确？

根据基本物理学知识我们知道：

~~~~{c}
s = ut + 0.5at^2
~~~~

在上式中，只需给定一个恒定的加速度，以及一个初始速度，我们就可以根据时间来求出位移。

在我们的例子中， u=0，因为一开始的时候车是静止的，所以：

~~~~{c}
s = 0.5at^2
s = 0.5(10)(10)^2
s = 0.5(10)(100)
s = 500 米
~~~~

如果我们使用欧拉积分来取代上面的精确计算的话，我们将得到：

~~~~{c}
t=0:     位置 = 0     速度 = 0
t=1:     位置 = 0     速度 = 10
t=2:     位置 = 10     速度 = 20
t=3:     位置 = 30     速度 = 30
t=4:     位置 = 60     速度 = 40
t=5:     位置 = 100     速度 = 50
t=6:     位置 = 150     速度 = 60
t=7:     位置 = 210     速度 = 70
t=8:     位置 = 280     速度 = 80
t=9:     位置 = 360     速度 = 90
t=10:     位置 = 450     速度 =100
~~~~

由上得出，如果我们使用了欧拉积分，那么在这个简单的计算中，10秒内就产生了50米的误差！悲剧的是，这个误差将会随着时间的增加而增大。

解决这个问题的其中一个方法是减小每次的时间间隔。例如，我们将时间间隔从1秒减小到1/100秒，这将会让我们得到一个相对更加精确的结果。

然而，无论你如何去减小时间间隔，误差始终存在，并且会随着时间的增加而增大。而上例只是一个相当单纯的例子，想象一下：将一条力矩曲线用到汽车上，或者再加入齿轮传动。汽车的加速度立马就不是常量了，它会随着时间而变化。现在再用积分求速度，这里就存在误差了，而当我们再来求位移的时候，误差还会被放大。

##世上还存在很多积分方法
显然你已经发现*显式欧拉*存在着很大的误差。但请不要武断认为它就是糟糕透顶的，永远都不该使用的。只需要心中明了它的缺陷。世上还有许多欧拉积分的变体，使用了不同的属性，有着不同的区域稳定性（regions of stability）。

例如，[半隐式欧拉(implicit euler/backward euler)][http://en.wikipedia.org/wiki/Semi_implicit_euler]，相对于显式欧拉，区别仅在于何时对速度进行取样。举例来说，它先使用加速度计算出当前的速度，然后再使用刚求出来的速度来求解位移。（显式欧拉则相反）。然而正是这给了积分器不同的属性，并且使它在更宽的时间间隔取值域中表现出更强的稳定性和节能性（energy conserving）。尽管他存在头号的积分误差。

另一个值得注意的是 [隐式欧拉](http://en.wikipedia.org/wiki/Implicit_Euler_method)。这种方法擅长处理刚性方程（例如：刚性弹簧）。它更加复杂，并且需要在每个时间间隔内去求解方程组，而其他方法仅需替换，相加等等简单操作。它的实现会和显示欧拉和半隐式欧拉有很大区别。

当对大量粒子进行物理模拟的时候有一个极好的方法：Verlet积分法(verlet integration)，它能极大增加准确率并能减少内存占用。在模拟粒子运动时，积分器不需要存储每个粒子的速度，而是从前两帧的位置来得出速度。这使得处理粒子间的碰撞所产生的位移修正变得相当迅速，并且易于实现。这里有一个极好的[例子](http://tomlee.co/misc/jakobsens-advanced-character-physics-annotated/)。

在这篇文章中我将介绍“RK4”积分器。全名：Runge Kutta order 4，这是以发现它的两名德国数学家的名字命名的：Carl Runge和Martin Kutta。虽说如此，但这并不意味着对任何程序来说RK4就是最好的积分器（它不是），也并不意味着相比于上文介绍的积分器，你该优先选择RK4（你不应这么做）。

但它是最精确的通用积分技术。如果想更深入地了解它，那就读下去吧。

##实现RK4并没有看上去那么难
我可以使用数学方程来描述RK4，然后你就可以像往常一样对某个函数的导数f(x, t)做积分操作了。但是鉴于我们的目标人群是程序员，而不是数学家，因此我将用代码的方式来描述。然对于我来说，用代码来描述也是最好的方式。

在我们深入细节之前，让我们先用C++来定义一个包含了位置和速度的结构体吧。

~~~~{c}
 struct State
 {
        float x;      // position
        float v;      // velocity
 };
~~~~

我们还需要一个用来存储状态值的导数，那样我们就可以方便地在函数之间传递它们了。这里我们存储了速度和加速度的导数。

~~~~{c}
struct Derivative
{
     float dx;
     float dv;
};
~~~~

实现RK4积分器所需的关键之处是要实现一个通过一组导数的值让物理状态从t推进到t+dt的函数。只要能实现这个函数，那么再使用新状态来重新计算导数，如此往复。这是实现RK4积分器的核心，用C++来实现的话，它看起来像这样：

~~~~{c}
Derivative evalute(const State &initial,
               float t,
               float dt,
               const Derivative &d)
{
     State state;
     state.x = initial.x + d.dx*dt;
     state.v = initial.v + d.dv*dt;

     Derivative output;
     output.dx = state.v;
     output.dv = acceleration(state, t+dt);
     return output;
}
~~~~

理解上面这个函数到底做了什么是及其重要的。首先它接受当前物体的状态（位置和速度）作为输入，然后从当前状态，根据传入的导数（速度和加速度）使用欧拉积分向前推演dt的时间。一旦新的位置和速度被计算出来，它会立即开始计算新的导数。*在时间间隔dt不是常量的情况下*，新计算出来的导数会和之前传入的值有所不同。

为了计算新的导数，它直接拷贝了当前状态的速度到derivative结构中（这是对位置和速度同时积分的技巧），然后调用acceleration函数来求出当前状态在时间t+dt时的加速度。正是加速度函数驱动了模拟物理世界的运行，在本例中代码如下：

~~~~{c}
float acceleration(const State &state, float t)
{
     const float k = 10;
     const float b = 1;
     return -k * state.x - b * state.v;
}
~~~~

上面函数计算了一个弹簧和摩擦力的和来作为加速度（在假设质量为1的情况下）。在上面函数怎么写，完全取决于你想要实现怎样的物理模拟，但是必须保证加速度是仅需通过传入的当前状态和时间来计算出来，不然你就没法使用RK4积分器。

最后让我们看看RK4积分器的具体实现：

~~~~{c}
void integrate( State &state,
                  float t,
                  float dt )
{
    Derivative a,b,c,d;

    a = evaluate( state, t, 0.0f, Derivative() );
    b = evaluate( state, t, dt*0.5f, a );
    c = evaluate( state, t, dt*0.5f, b );
    d = evaluate( state, t, dt, c );

    float dxdt = 1.0f / 6.0f *
        ( a.dx + 2.0f*(b.dx + c.dx) + d.dx );

    float dvdt = 1.0f / 6.0f *
        ( a.dv + 2.0f*(b.dv + c.dv) + d.dv );

    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
}
~~~~

请注意上面过程多次调用了evaluate函数。RK4共求取了4次导数来确定曲率，而不是仅仅一次欧拉积分。最重要的是要理解它是如何采样的。

上面的代码应该是比较容易理解的。注意它是如何使用前一个导数来求取下一个导数的。它基于导数a将时间向前推进至t+dt*0.5来计算导数b，然后又使用b来计算了c，最终使用c来计算了d。正是这种使用当前导数计算下一个导数的方法给了RK4高精确性。

计算完4个导数取样后，使用泰勒级数展开来求取一个全局最佳的导数。这个导数值将会被用来和dt一起来推进位置和速度，就和之前欧拉积分一样。

需要注意的是，即使使用了像RK4一样复杂的积分器，仍将会归结到 某种状态 = 某种状态 + 某种状态的变化率 * 时间的变化。这是因为微积分从根本上来说还是先行操作。当前我们只是对单个值积分，后面我们会遇到对向量，甚至四元数和矩阵（用于动态旋转）。

##结论
上文已经演示了如何为基本的物理模拟实现一个RK4积分器，如果你是真正想学习游戏物理的话，我建议你再学习一下本文的[示例代码](http://gamephysics.googlecode.com/files/IntegrationBasics.zip)。


[原文地址](http://gafferongames.com/game-physics/integration-basics/)
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">简介</h2>

<p>Hi，我是Glenn Fiedler，欢迎来到<a href="http://www.gafferongames.com/game-physics/">游戏物理</a>系列的第一篇文章。</p>

<p>如果你曾为电脑是如何模拟物理效果感到困惑，那么这一系列文章正好可以为你答疑解惑。我将假设你能熟练使用C++语言，并且对物理和数学的基础知识有所了解。那么你就可以愉快得开始学习本系列文章了。</p>

<p>游戏中的物理模拟(physics simulation)的工作原理，是基于物理法则来进行许多微小的预测。这些预测实际上相当简单，基本上都可以被归纳为一些简单的事情，比方说：一个物体现在在这里，以一定速度运动，在一小段时间后它应该在那儿。我们通过一种叫做“积分”(integration)的数学技巧来实现这种预测。</p>

<h2 id="">对运动方程积分</h2>

<p>你也许还记得高中或大学的时候，物理课的知识：力 = 质量 * 加速度。变换一下这个方程，我们能得到：加速度 = 力 / 质量。这告诉我们当物体质量越大时，施加相同的力所能产生的加速度就越小。</p>

<pre class=" language-bash"><code class=" language-bash">f <span class="token operator">=</span> ma
a <span class="token operator">=</span> f<span class="token operator">/</span>m
</code></pre>

<p>由于加速度其实就是速度根据时间的变化率，并且加速度等于力除以质量，综上可以得出力除以质量就是速度的变化速率</p>

<pre class=" language-bash"><code class=" language-bash">dv<span class="token operator">/</span>dt <span class="token operator">=</span> a <span class="token operator">=</span> F<span class="token operator">/</span>m
</code></pre>

<p>类似的，速度是位移相对时间的变化量</p>

<pre class=" language-bash"><code class=" language-bash">dx<span class="token operator">/</span>dt <span class="token operator">=</span> v
</code></pre>

<p>这意味着如果我们知道一个物体当前的位置和速度，并且知道将会施加给物体的力，我们可以通过“积分”来得到物体在未来某个时间点上的位置。</p>

<h2 id="numericalintegration">数值积分(Numerical Integration)</h2>

<p>对于没有在大学中系统学习过各种数学方程的朋友，不用担心，你和那些学过的朋友基本是站在同一起跑线上的。这是因为我们并不着眼于去解决学习微积分的第一年遇到的各种方程推导问题，而是将目光放在如何使用数值积分来找出问题的解决方案。</p>

<p>接下来让我们看看数值积分是如何运作的。首先，开始时物体具有初始的<em>位置</em>和<em>速度</em>，然后找出经过一小段时间后物体的<em>位置</em>和<em>速度</em>。不断重复上述过程，每次重复的起始位置和速度都使用上次过程产生的结果。</p>

<p>简单起见，让我们假设时间每次向前推进一秒。首先我们处在初始的位置，拥有初始的速度，然后让我们计算出在一秒内速度和位置的变化量是多少。然后将这些变化量累加到速度和位置上，并不断重复此过程。从初始1秒时的速度计算1秒内的变化量来得出在2秒时的速度和位置，如此反复，即可得出3，4，5秒时物体的状态。</p>

<p>但我们如何能知道每个时间间隔内速度的变化量是多少呢？答案就在上文所述的那堆<em>运动方程</em>中。我们通过<code>力</code>除以<code>质量</code>来得出<code>加速度</code>。 由于加速度是<code>每秒速度变化量</code>，我们能够得出<code>速度的变化量</code>为 <code>加速度</code> * <code>时间</code>(以秒为单位)。类似的，<code>位置的变化量</code>为 <code>速度</code> * <code>时间</code>。</p>

<p>我们将用t表示时间，用每个dt(delta time)表示时间间隔， 让我们用通俗易懂的方式来表达运动方程：</p>

<ul>
<li>加速度 = 力 / 质量</li>
<li>速度变化量 = 加速度 * 时间间隔dt</li>
<li>位置变化量 = 速度 * 时间间隔dt</li>
</ul>

<p>这些方程是有意义的，因为如果我们知道一辆车以60km每小时的速度移动，那么在一小时后这辆车将开到60km开外的地方。类似的，如果一辆车以10km/h/s的加速度，从静止开始运动，那么10秒后它将正好以100km/h的速度行驶。</p>

<p>让我们将这些过程转化成代码。假设最初的位置和速度都为零，我们能通过将本次时间间隔产生的位置和速度的变化量和上次时间间隔的位置和速度进行累加来实现对运动方程的积分。</p>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">float</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> dt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">float</span> velocity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> force <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> mass <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span> t <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    position <span class="token operator">=</span> position <span class="token operator">+</span> velocity <span class="token operator">*</span> dt<span class="token punctuation">;</span>
    velocity <span class="token operator">=</span> velocity <span class="token operator">+</span> <span class="token punctuation">(</span> force <span class="token operator">/</span> mass <span class="token punctuation">)</span> <span class="token operator">*</span> dt<span class="token punctuation">;</span>
    t <span class="token operator">=</span> t <span class="token operator">+</span> dt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>注意积分出来的速度和位置是如何提供给下一帧的。这里每次使用最近一次计算出来的积分得到时间和位置差值来更新汽车的位置和速度，由此我们可以知道在任意一秒这辆汽车行驶了多远，以及它在以多快的速度行驶。

##为什么欧拉不总是那么完美无缺
我们上述所做的内容叫做欧拉积分(Euler Integration)。它是积分的一种特殊形式，叫做显式欧拉(explicit euler)[http://en.wikipedia.org/wiki/Euler_method]。

为了不让尴尬的事情发生，我得提前告诉你Euler的发音是"Oiler"，而不是“yew-ler”,因为欧拉积分是以发现了这个数学技巧的瑞典数学家莱昂哈德·欧拉的姓氏命名的。

欧拉积分是最基础的数值积分技巧。它只在变化率相对于时间间隔恒定的时候才有100%的正确率。例如上例中对速度的积分就是正确的，因为加速度是恒定的10米每秒。但是如果我们想通过对速度的积分来求位置的话，那就不是完全正确了。这是因为速度不是恒定值，由于加速度的存在，速度会随着时间不断改变。

这意味着随着时间的推移，积分所产生的x(t)和v(t)会和真实的值产生越来越大的偏差。在上例中，由于使用了积分，汽车的位移是不精确的。

那欧拉积分到底有多不精确？

根据基本物理学知识我们知道：

<pre class=" language-c"><code class=" language-c">s <span class="token operator">=</span> ut <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">.</span>5at<span class="token operator">^</span><span class="token number">2</span>
</code></pre>

<p>在上式中，只需给定一个恒定的加速度，以及一个初始速度，我们就可以根据时间来求出位移。</p>

<p>在我们的例子中， u=0，因为一开始的时候车是静止的，所以：</p>

<pre class=" language-c"><code class=" language-c">s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>5at<span class="token operator">^</span><span class="token number">2</span>
s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">5<span class="token punctuation">(</span></span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">2</span>
s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">5<span class="token punctuation">(</span></span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
s <span class="token operator">=</span> <span class="token number">500</span> 米
</code></pre>

<p>如果我们使用欧拉积分来取代上面的精确计算的话，我们将得到：</p>

<pre class=" language-c"><code class=" language-c">t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">0</span>     速度 <span class="token operator">=</span> <span class="token number">0</span>
t<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">0</span>     速度 <span class="token operator">=</span> <span class="token number">10</span>
t<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">10</span>     速度 <span class="token operator">=</span> <span class="token number">20</span>
t<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">30</span>     速度 <span class="token operator">=</span> <span class="token number">30</span>
t<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">60</span>     速度 <span class="token operator">=</span> <span class="token number">40</span>
t<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">100</span>     速度 <span class="token operator">=</span> <span class="token number">50</span>
t<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">150</span>     速度 <span class="token operator">=</span> <span class="token number">60</span>
t<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">210</span>     速度 <span class="token operator">=</span> <span class="token number">70</span>
t<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">280</span>     速度 <span class="token operator">=</span> <span class="token number">80</span>
t<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">360</span>     速度 <span class="token operator">=</span> <span class="token number">90</span>
t<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">:</span>     位置 <span class="token operator">=</span> <span class="token number">450</span>     速度 <span class="token operator">=</span><span class="token number">100</span>
</code></pre>

<p>由上得出，如果我们使用了欧拉积分，那么在这个简单的计算中，10秒内就产生了50米的误差！悲剧的是，这个误差将会随着时间的增加而增大。</p>

<p>解决这个问题的其中一个方法是减小每次的时间间隔。例如，我们将时间间隔从1秒减小到1/100秒，这将会让我们得到一个相对更加精确的结果。</p>

<p>然而，无论你如何去减小时间间隔，误差始终存在，并且会随着时间的增加而增大。而上例只是一个相当单纯的例子，想象一下：将一条力矩曲线用到汽车上，或者再加入齿轮传动。汽车的加速度立马就不是常量了，它会随着时间而变化。现在再用积分求速度，这里就存在误差了，而当我们再来求位移的时候，误差还会被放大。</p>

<h2 id="">世上还存在很多积分方法</h2>

<p>显然你已经发现<em>显式欧拉</em>存在着很大的误差。但请不要武断认为它就是糟糕透顶的，永远都不该使用的。只需要心中明了它的缺陷。世上还有许多欧拉积分的变体，使用了不同的属性，有着不同的区域稳定性（regions of stability）。</p>

<p>例如，[半隐式欧拉(implicit euler/backward euler)][http://en.wikipedia.org/wiki/Semi<em>implicit</em>euler]，相对于显式欧拉，区别仅在于何时对速度进行取样。举例来说，它先使用加速度计算出当前的速度，然后再使用刚求出来的速度来求解位移。（显式欧拉则相反）。然而正是这给了积分器不同的属性，并且使它在更宽的时间间隔取值域中表现出更强的稳定性和节能性（energy conserving）。尽管他存在头号的积分误差。</p>

<p>另一个值得注意的是 <a href="http://en.wikipedia.org/wiki/Implicit_Euler_method">隐式欧拉</a>。这种方法擅长处理刚性方程（例如：刚性弹簧）。它更加复杂，并且需要在每个时间间隔内去求解方程组，而其他方法仅需替换，相加等等简单操作。它的实现会和显示欧拉和半隐式欧拉有很大区别。</p>

<p>当对大量粒子进行物理模拟的时候有一个极好的方法：Verlet积分法(verlet integration)，它能极大增加准确率并能减少内存占用。在模拟粒子运动时，积分器不需要存储每个粒子的速度，而是从前两帧的位置来得出速度。这使得处理粒子间的碰撞所产生的位移修正变得相当迅速，并且易于实现。这里有一个极好的<a href="http://tomlee.co/misc/jakobsens-advanced-character-physics-annotated/">例子</a>。</p>

<p>在这篇文章中我将介绍“RK4”积分器。全名：Runge Kutta order 4，这是以发现它的两名德国数学家的名字命名的：Carl Runge和Martin Kutta。虽说如此，但这并不意味着对任何程序来说RK4就是最好的积分器（它不是），也并不意味着相比于上文介绍的积分器，你该优先选择RK4（你不应这么做）。</p>

<p>但它是最精确的通用积分技术。如果想更深入地了解它，那就读下去吧。</p>

<h2 id="rk4">实现RK4并没有看上去那么难</h2>

<p>我可以使用数学方程来描述RK4，然后你就可以像往常一样对某个函数的导数f(x, t)做积分操作了。但是鉴于我们的目标人群是程序员，而不是数学家，因此我将用代码的方式来描述。然对于我来说，用代码来描述也是最好的方式。</p>

<p>在我们深入细节之前，让我们先用C++来定义一个包含了位置和速度的结构体吧。</p>

<pre class=" language-c"><code class=" language-c"> <span class="token keyword">struct</span> State
 <span class="token punctuation">{</span>
        <span class="token keyword">float</span> x<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true"> // position
</span>        <span class="token keyword">float</span> v<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true"> // velocity
</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>

<p>我们还需要一个用来存储状态值的导数，那样我们就可以方便地在函数之间传递它们了。这里我们存储了速度和加速度的导数。</p>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">struct</span> Derivative
<span class="token punctuation">{</span>
     <span class="token keyword">float</span> dx<span class="token punctuation">;</span>
     <span class="token keyword">float</span> dv<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>

<p>实现RK4积分器所需的关键之处是要实现一个通过一组导数的值让物理状态从t推进到t+dt的函数。只要能实现这个函数，那么再使用新状态来重新计算导数，如此往复。这是实现RK4积分器的核心，用C++来实现的话，它看起来像这样：</p>

<pre class=" language-c"><code class=" language-c">Derivative <span class="token function">evalute<span class="token punctuation">(</span></span><span class="token keyword">const</span> State <span class="token operator">&amp;</span>initial<span class="token punctuation">,</span>
               <span class="token keyword">float</span> t<span class="token punctuation">,</span>
               <span class="token keyword">float</span> dt<span class="token punctuation">,</span>
               <span class="token keyword">const</span> Derivative <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     State state<span class="token punctuation">;</span>
     state<span class="token punctuation">.</span>x <span class="token operator">=</span> initial<span class="token punctuation">.</span>x <span class="token operator">+</span> d<span class="token punctuation">.</span>dx<span class="token operator">*</span>dt<span class="token punctuation">;</span>
     state<span class="token punctuation">.</span>v <span class="token operator">=</span> initial<span class="token punctuation">.</span>v <span class="token operator">+</span> d<span class="token punctuation">.</span>dv<span class="token operator">*</span>dt<span class="token punctuation">;</span>

     Derivative output<span class="token punctuation">;</span>
     output<span class="token punctuation">.</span>dx <span class="token operator">=</span> state<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
     output<span class="token punctuation">.</span>dv <span class="token operator">=</span> <span class="token function">acceleration<span class="token punctuation">(</span></span>state<span class="token punctuation">,</span> t<span class="token operator">+</span>dt<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>理解上面这个函数到底做了什么是及其重要的。首先它接受当前物体的状态（位置和速度）作为输入，然后从当前状态，根据传入的导数（速度和加速度）使用欧拉积分向前推演dt的时间。一旦新的位置和速度被计算出来，它会立即开始计算新的导数。<em>在时间间隔dt不是常量的情况下</em>，新计算出来的导数会和之前传入的值有所不同。</p>

<p>为了计算新的导数，它直接拷贝了当前状态的速度到derivative结构中（这是对位置和速度同时积分的技巧），然后调用acceleration函数来求出当前状态在时间t+dt时的加速度。正是加速度函数驱动了模拟物理世界的运行，在本例中代码如下：</p>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">float</span> <span class="token function">acceleration<span class="token punctuation">(</span></span><span class="token keyword">const</span> State <span class="token operator">&amp;</span>state<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">const</span> <span class="token keyword">float</span> k <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
     <span class="token keyword">const</span> <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token operator">-</span>k <span class="token operator">*</span> state<span class="token punctuation">.</span>x <span class="token operator">-</span> b <span class="token operator">*</span> state<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>上面函数计算了一个弹簧和摩擦力的和来作为加速度（在假设质量为1的情况下）。在上面函数怎么写，完全取决于你想要实现怎样的物理模拟，但是必须保证加速度是仅需通过传入的当前状态和时间来计算出来，不然你就没法使用RK4积分器。</p>

<p>最后让我们看看RK4积分器的具体实现：</p>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">void</span> <span class="token function">integrate<span class="token punctuation">(</span></span> State <span class="token operator">&amp;</span>state<span class="token punctuation">,</span>
                  <span class="token keyword">float</span> t<span class="token punctuation">,</span>
                  <span class="token keyword">float</span> dt <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Derivative a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">;</span>

    a <span class="token operator">=</span> <span class="token function">evaluate<span class="token punctuation">(</span></span> state<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span>0f<span class="token punctuation">,</span> <span class="token function">Derivative<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token function">evaluate<span class="token punctuation">(</span></span> state<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dt<span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">.</span>5f<span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token function">evaluate<span class="token punctuation">(</span></span> state<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dt<span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">.</span>5f<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
    d <span class="token operator">=</span> <span class="token function">evaluate<span class="token punctuation">(</span></span> state<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dt<span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> dxdt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span>0f <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">.</span>0f <span class="token operator">*</span>
        <span class="token punctuation">(</span> a<span class="token punctuation">.</span>dx <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">.</span>0f<span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>dx <span class="token operator">+</span> c<span class="token punctuation">.</span>dx<span class="token punctuation">)</span> <span class="token operator">+</span> d<span class="token punctuation">.</span>dx <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> dvdt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span>0f <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">.</span>0f <span class="token operator">*</span>
        <span class="token punctuation">(</span> a<span class="token punctuation">.</span>dv <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">.</span>0f<span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>dv <span class="token operator">+</span> c<span class="token punctuation">.</span>dv<span class="token punctuation">)</span> <span class="token operator">+</span> d<span class="token punctuation">.</span>dv <span class="token punctuation">)</span><span class="token punctuation">;</span>

    state<span class="token punctuation">.</span>x <span class="token operator">=</span> state<span class="token punctuation">.</span>x <span class="token operator">+</span> dxdt <span class="token operator">*</span> dt<span class="token punctuation">;</span>
    state<span class="token punctuation">.</span>v <span class="token operator">=</span> state<span class="token punctuation">.</span>v <span class="token operator">+</span> dvdt <span class="token operator">*</span> dt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>请注意上面过程多次调用了evaluate函数。RK4共求取了4次导数来确定曲率，而不是仅仅一次欧拉积分。最重要的是要理解它是如何采样的。</p>

<p>上面的代码应该是比较容易理解的。注意它是如何使用前一个导数来求取下一个导数的。它基于导数a将时间向前推进至t+dt*0.5来计算导数b，然后又使用b来计算了c，最终使用c来计算了d。正是这种使用当前导数计算下一个导数的方法给了RK4高精确性。</p>

<p>计算完4个导数取样后，使用泰勒级数展开来求取一个全局最佳的导数。这个导数值将会被用来和dt一起来推进位置和速度，就和之前欧拉积分一样。</p>

<p>需要注意的是，即使使用了像RK4一样复杂的积分器，仍将会归结到 某种状态 = 某种状态 + 某种状态的变化率 * 时间的变化。这是因为微积分从根本上来说还是先行操作。当前我们只是对单个值积分，后面我们会遇到对向量，甚至四元数和矩阵（用于动态旋转）。</p>

<h2 id="">结论</h2>

<p>上文已经演示了如何为基本的物理模拟实现一个RK4积分器，如果你是真正想学习游戏物理的话，我建议你再学习一下本文的<a href="http://gamephysics.googlecode.com/files/IntegrationBasics.zip">示例代码</a>。</p>

<p><a href="http://gafferongames.com/game-physics/integration-basics/">原文地址</a></p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>↖(▔＾▔)↗</p>
	</div>
<!-- duoshuo -->
<div class="ds-thread" data-thread-key="WRXUluZWdyYXRpb24gQmFzaWNz" data-title="[翻译]Inegration Basics" data-url=hot.github.io"WRXUluZWdyYXRpb24gQmFzaWNz.html"></div>
<!-- duoshuo end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"hotgithub"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</div>
<script src="../main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "../main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "WRXUluZWdyYXRpb24gQmFzaWNz.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
